import numpy as np
from matplotlib import gridspec
import matplotlib.pyplot as plt
from PyOSGPUP.signalpy import hilbert


def plot_vawig(axhdl, data, t, excursion, highlight=None):
    [ntrc, nsamp] = data.shape

    t = np.hstack([0, t, t.max()])

    for i in range(0, ntrc):
        tbuf = excursion * data[i] / np.max(np.abs(data)) + i

        tbuf = np.hstack([i, tbuf, i])

        if i == highlight:
            lw = 2
        else:
            lw = 0.5

        axhdl.plot(tbuf, t, color='black', linewidth=lw)

        plt.fill_betweenx(t, tbuf, i, where=tbuf > i, facecolor=[0.6, 0.6, 1.0], linewidth=0)
        plt.fill_betweenx(t, tbuf, i, where=tbuf < i, facecolor=[1.0, 0.7, 0.7], linewidth=0)

    axhdl.set_xlim((-excursion, ntrc + excursion))
    axhdl.xaxis.tick_top()
    axhdl.xaxis.set_label_position('top')
    axhdl.invert_yaxis()


def ricker(cfreq, phase, dt, wvlt_length):
    '''
    Calculate a ricker wavelet

    Usage:
    ------
    t, wvlt = wvlt_ricker(cfreq, phase, dt, wvlt_length)

    cfreq: central frequency of wavelet in Hz
    phase: wavelet phase in degrees
    dt: sample rate in seconds
    wvlt_length: length of wavelet in seconds
    '''

    nsamp = int(wvlt_length / dt + 1)
    t_max = wvlt_length * 0.5
    t_min = -t_max

    t = np.arange(t_min, t_max, dt)

    t = np.linspace(-wvlt_length / 2, (wvlt_length - dt) / 2, wvlt_length / dt)
    wvlt = (1.0 - 2.0 * (np.pi ** 2) * (cfreq ** 2) * (t ** 2)) * np.exp(-(np.pi ** 2) * (cfreq ** 2) * (t ** 2))

    if phase != 0:
        phase = phase * np.pi / 180.0
        wvlth = hilbert(wvlt)
        wvlth = np.imag(wvlth)
        wvlt = np.cos(phase) * wvlt - np.sin(phase) * wvlth

    return t, wvlt


def wvlt_bpass(f1, f2, f3, f4, phase, dt, wvlt_length):
    '''
    Calculate a trapezoidal bandpass wavelet

    Usage:
    ------
    t, wvlt = wvlt_ricker(f1, f2, f3, f4, phase, dt, wvlt_length)

    f1: Low truncation frequency of wavelet in Hz
    f2: Low cut frequency of wavelet in Hz
    f3: High cut frequency of wavelet in Hz
    f4: High truncation frequency of wavelet in Hz
    phase: wavelet phase in degrees
    dt: sample rate in seconds
    wvlt_length: length of wavelet in seconds
    '''

    from numpy.fft import fft, ifft, fftfreq, fftshift, ifftshift

    nsamp = int(wvlt_length / dt + 1)

    freq = fftfreq(nsamp, dt)
    freq = fftshift(freq)
    aspec = freq * 0.0
    pspec = freq * 0.0

    # Calculate slope and y-int for low frequency ramp
    M1 = 1 / (f2 - f1)
    b1 = -M1 * f1

    # Calculate slop and y-int for high frequency ramp
    M2 = -1 / (f4 - f3)
    b2 = -M2 * f4

    # Build initial frequency and filter arrays
    freq = fftfreq(nsamp, dt)
    freq = fftshift(freq)
    filt = np.zeros(nsamp)

    # Build LF ramp
    idx = np.nonzero((np.abs(freq) >= f1) & (np.abs(freq) < f2))
    filt[idx] = M1 * np.abs(freq)[idx] + b1

    # Build central filter flat
    idx = np.nonzero((np.abs(freq) >= f2) & (np.abs(freq) <= f3))
    filt[idx] = 1.0

    # Build HF ramp
    idx = np.nonzero((np.abs(freq) > f3) & (np.abs(freq) <= f4))
    filt[idx] = M2 * np.abs(freq)[idx] + b2

    # Unshift the frequencies and convert filter to fourier coefficients
    filt2 = ifftshift(filt)
    Af = filt2 * np.exp(np.zeros(filt2.shape) * 1j)

    # Convert filter to time-domain wavelet
    wvlt = fftshift(ifft(Af))
    wvlt = np.real(wvlt)
    wvlt = wvlt / np.max(np.abs(wvlt))  # normalize wavelet by peak amplitude

    # Generate array of wavelet times
    t = np.linspace(-wvlt_length * 0.5, wvlt_length * 0.5, nsamp)

    # Apply phase rotation if desired
    if phase != 0:
        phase = phase * np.pi / 180.0
        wvlth = hilbert(wvlt)
        wvlth = np.imag(wvlth)
        wvlt = np.cos(phase) * wvlt - np.sin(phase) * wvlth

    return t, wvlt


def calc_rc(vp_mod, rho_mod):
    '''
    rc_int = calc_rc(vp_mod, rho_mod)
    '''

    nlayers = len(vp_mod)
    nint = nlayers - 1

    rc_int = []
    for i in range(0, nint):
        buf1 = vp_mod[i + 1] * rho_mod[i + 1] - vp_mod[i] * rho_mod[i]
        buf2 = vp_mod[i + 1] * rho_mod[i + 1] + vp_mod[i] * rho_mod[i]
        buf3 = buf1 / buf2
        rc_int.append(buf3)

    return rc_int

def calc_times(z_int, vp_mod):
    '''
    t_int = calc_times(z_int, vp_mod)
    '''

    nlayers = len(vp_mod)
    nint = nlayers - 1

    t_int = []
    for i in range(0, nint):
        if i == 0:
            tbuf = z_int[i] / vp_mod[i]
            t_int.append(tbuf)
        else:
            zdiff = z_int[i] - z_int[i - 1]
            tbuf = 2 * zdiff / vp_mod[i] + t_int[i - 1]
            t_int.append(tbuf)

    return t_int

def digitize_model(rc_int, t_int, t):
    '''
    rc = digitize_model(rc, t_int, t)

    rc = reflection coefficients corresponding to interface times
    t_int = interface times
    t = regularly sampled time series defining model sampling
    '''

    import numpy as np

    nlayers = len(rc_int)
    nint = nlayers - 1
    nsamp = len(t)

    rc = list(np.zeros(nsamp, dtype='float'))
    lyr = 0

    for i in range(0, nsamp):

        if t[i] >= t_int[lyr]:
            rc[i] = rc_int[lyr]
            lyr = lyr + 1

        if lyr > nint:
            break

    return rc


def wedge_tuning(mod,bound_mod,wave_parm,freq,trace_parm,plot_parm):
    ###########################################################
    #
    #       DEFINE MODELING PARAMETERS HERE
    #

    #   3-Layer Model Parameters [Layer1, Layer2, Layer 3]
    vp_mod = mod[0]  # P-wave velocity (m/s)
    vs_mod = mod[1]  # S-wave velocity (m/s)
    rho_mod = mod[2]  # Density (g/cc)

    dz_min = bound_mod[0]  # Minimum thickness of Layer 2 (m)
    dz_max = bound_mod[1]  # Maximum thickness of Layer 2 (m)
    dz_step = bound_mod[2]  # Thickness step from trace-to-trace (normally 1.0 m)

    #   Wavelet Parameters
    wvlt_type = wave_parm[0]  # Valid values: 'ricker' or 'bandpass'
    wvlt_length = wave_parm[1]  # Wavelet length in seconds
    wvlt_phase = wave_parm[2]  # Wavelet phase in degrees
    wvlt_scalar = wave_parm[3]  # Multiplier to scale wavelet amplitude (default = 1.0)
    wvlt_cfreq = wave_parm[4]  # Ricker wavelet central frequency
    f1 = freq[0]  # Bandpass wavelet low truncation frequency
    f2 = freq[1]  # Bandpass wavelet low cut frequency
    f3 = freq[2]  # Bandpass wavelet high cut frequency
    f4 = freq[3]  # Bandpass wavelet high truncation frequency

    #   Trace Parameters
    tmin = trace_parm[0]
    tmax = trace_parm[1]
    dt = trace_parm[2]  # changing this from 0.0001 can affect the display quality

    #   Plot Parameters
    min_plot_time = plot_parm[0]
    max_plot_time = plot_parm[1]
    excursion = plot_parm[2]

    ###########################################################
    #
    #       DEFINE MODELING PARAMETERS HERE
    #

    #   Some handy constants
    nlayers = len(vp_mod)
    nint = nlayers - 1
    nmodel = int((dz_max - dz_min) / dz_step + 1)


    #   Generate wavelet
    if wvlt_type == 'ricker':
        wvlt_t, wvlt_amp = ricker(wvlt_cfreq, wvlt_phase, dt, wvlt_length)

    elif wvlt_type == 'bandpass':
        wvlt_t, wvlt_amp = wvlt_bpass(f1, f2, f3, f4, wvlt_phase, dt, wvlt_length)

    #   Apply amplitude scale factor to wavelet (to match seismic amplitude values)
    wvlt_amp = wvlt_scalar * wvlt_amp

    #   Calculate reflectivities from model parameters
    rc_int = calc_rc(vp_mod, rho_mod)

    syn_zo = []
    rc_zo = []
    lyr_times = []
    for model in range(0, nmodel):

        #   Calculate interface depths
        z_int = [500.0]
        z_int.append(z_int[0] + dz_min + dz_step * model)

        #   Calculate interface times
        t_int = calc_times(z_int, vp_mod)
        lyr_times.append(t_int)

        #   Digitize 3-layer model
        nsamp = int((tmax - tmin) / dt) + 1
        t = []
        for i in range(0, nsamp):
            t.append(i * dt)

        rc = digitize_model(rc_int, t_int, t)
        rc_zo.append(rc)

        #   Convolve wavelet with reflectivities
        syn_buf = np.convolve(rc, wvlt_amp, mode='same')
        syn_buf = list(syn_buf)
        syn_zo.append(syn_buf)
        print("finished step %i" % (model))

    syn_zo = np.array(syn_zo)
    t = np.array(t)
    lyr_times = np.array(lyr_times)
    lyr_indx = np.array(np.round(lyr_times / dt), dtype='int16')

    # Use the transpose because rows are traces;
    # columns are time samples.
    tuning_trace = np.argmax(np.abs(syn_zo.T)) % syn_zo.T.shape[1]
    tuning_thickness = tuning_trace * dz_step

    #   Plotting Code
    [ntrc, nsamp] = syn_zo.shape

    fig = plt.figure(figsize=(12, 14))
    fig.set_facecolor('white')

    gs = gridspec.GridSpec(3, 1, height_ratios=[1, 1, 1])

    ax0 = fig.add_subplot(gs[0])
    ax0.plot(lyr_times[:, 0], color='blue', lw=1.5)
    ax0.plot(lyr_times[:, 1], color='red', lw=1.5)
    ax0.set_ylim((min_plot_time, max_plot_time))
    ax0.invert_yaxis()
    ax0.set_xlabel('Thickness (m)')
    ax0.set_ylabel('Time (s)')
    plt.text(2,
             min_plot_time + (lyr_times[0, 0] - min_plot_time) / 2.,
             'Layer 1',
             fontsize=16)
    plt.text(dz_max / dz_step - 2,
             lyr_times[-1, 0] + (lyr_times[-1, 1] - lyr_times[-1, 0]) / 2.,
             'Layer 2',
             fontsize=16,
             horizontalalignment='right')
    plt.text(2,
             lyr_times[0, 0] + (max_plot_time - lyr_times[0, 0]) / 2.,
             'Layer 3',
             fontsize=16)
    plt.gca().xaxis.tick_top()
    plt.gca().xaxis.set_label_position('top')
    ax0.set_xlim((-excursion, ntrc + excursion))

    ax1 = fig.add_subplot(gs[1])
    plot_vawig(ax1, syn_zo, t, excursion, highlight=tuning_trace)
    ax1.plot(lyr_times[:, 0], color='blue', lw=1.5)
    ax1.plot(lyr_times[:, 1], color='red', lw=1.5)
    ax1.set_ylim((min_plot_time, max_plot_time))
    ax1.invert_yaxis()
    ax1.set_xlabel('Thickness (m)')
    ax1.set_ylabel('Time (s)')

    ax2 = fig.add_subplot(gs[2])
    ax2.plot(syn_zo[:, lyr_indx[:, 0]], color='blue')
    ax2.set_xlim((-excursion, ntrc + excursion))
    ax2.axvline(tuning_trace, color='k', lw=2)
    ax2.grid()
    ax2.set_title('Upper interface amplitude')
    ax2.set_xlabel('Thickness (m)')
    ax2.set_ylabel('Amplitude')
    plt.text(tuning_trace + 2,
             plt.ylim()[0] * 1.1,
             'tuning thickness = {0} m'.format(str(tuning_thickness)),
             fontsize=16)

    plt.show()





